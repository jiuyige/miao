
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas width="1000" height="1000"></canvas>
</body>
<script>
  var canvas = document.querySelector('canvas')
  canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
  var ctx = canvas.getContext('2d')

  function dot(x, y, color = 'black') {
    x = Math.round(x)
    y = Math.round(y)
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
  /**
   * 你的任务：通过调用dot函数，实现：
   * 需要注意，dot函数不能接收浮点数，如果参数为浮点数，会被转换为整数后绘制
      * 在 坐标 (42, 42) 画出一个点
      * 画一条水平实线，粗细为一个像素
      * 画一条垂直实线，粗细为一个像素
      * 画一条一个实点一个空点的虚线
      * 画一条两个实点两个空点的虚线
      * 画一条三个实点两个空点的虚线
      * 画一条45度的斜线
      * 画一条30度的斜线（与x轴的夹角呈30度）
      * 画一条60度的斜线（与x轴的夹角呈60度）
      * 画一条跨越画布左上角和右下角的对角线
      * 画一个空心矩形
      * 画一个实心矩形
      * 画两个空心的圆，圆心在画布中心：
        * 一个半径为50像素
        * 一个半径为200像素
      * 画一个实心的圆，半径至少为100像素
      * 画一个【大小位置都合适】的sin(x)的图像

      * 画出rgb色彩空间的某一面（尺寸要大于100x100）
      * 如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变换后的色彩空间某一面
        可以考虑如下几种矩阵：
           2 0
           0 2
           ------
           1  0.27
           0  1
           ------
           0.5    0.87
           -0.87  0.5
      * 画一个二阶贝塞尔曲线（即控制点一共三个）

      var bezierCurve = function(x1,y1,x2,y2,x3,y3) {


      }

   */
</script>
<script>
  // 不可更改上面的代码
  // 你的代码写在这里


  //在 坐标 (42, 42) 画出一个点 
  dot(42,42,'red')

  //画一条水平实线，粗细为一个像素
  for (var x = 0; x < 100; x++) {
    dot (x, 50, 'yellow')
  }

  //画一条垂直实线，粗细为一个像素
  for (var y = 100; y < 300 ; y++){
    dot (50, y, 'red')
  }

  //画一条一个实点一个空点的虚线
  for (var x = 10; x < 100; x += 2) {
    dot (x, 350)
  }
  //画一条两个实点两个空点的虚线
  for (var x = 10; x < 200; x += 4) {
    dot (x, 450)
    dot (x + 1, 450)
  }
  //画一条三个实点两个空点的虚线
  for (var x = 10; x < 200; x += 5) {
      dot (x, 500)
      dot (x + 1, 500)
      dot (x + 2, 500)
  }

  //画一条45度的斜线
  for (var x = 0; x < 200; x++) {
    dot (x, x, 'pink')
  }

  //画一条30度的斜线（与x轴的夹角呈30度）
  for (var x = 0; x < 200; x++) {
    var y = 0.4 * x
    dot(x, y, 'black')
  }

  //画一条60度的斜线（与x轴的夹角呈60度)
  for (var y = 0; y < 100; y++) {
    var x = 0.6 * y
    dot (x, y, 'blue')
  }
  //画一条跨越画布左上角和右下角的对角线
  for (var x = 0; x < 1000; x++) {
    var y = x
    dot (x, y, 'black')
  }
  //画一个空心矩形
  for (var x = 300; x <= 500; x++) {
    dot (x, 50, 'black')
  }
  for (var y = 50; y <= 250; y++){
    dot (300, y, 'black')
  }
  for (var x = 300; x <= 500; x++) {
    dot (x, 250, 'black')
  }
  for (var y = 50; y <= 250; y++){
    dot (500, y, 'black')
  }

  //画一个实心矩形
  var startX = 300;
  var startY = 500;
  var width = 100;
  var height = 100;
  for (var x = startX; x < startX + width; x++) {
    for (var y = startY; y < startY + height; y++) {
        dot(x, y, 'blue');
    }
  }

  //画两个空心的圆，圆心在画布中心：
  //一个半径为50像素
  var canvasWidth = 1000
  var canvasHeight = 1000
  var centerx = canvasWidth / 2
  var centery = canvasHeight / 2
  var radius1 = 50
  var radius2 = 200
  for (var angle = 0; angle < 360; angle++) {
      var radians = angle * (Math.PI / 180)
      var x = centerx + radius1 * Math.cos(radians)
      var y = centery + radius1 * Math.sin(radians)
      dot (x, y, 'black')
  }
  //一个半径为200像素
  for (var angle = 0; angle < 360; angle++) {
    var radians = angle * (Math.PI / 180)
    var x = centerx + radius2 * Math.cos(radians)
    var y = centery + radius2 * Math.sin(radians)
    dot (x, y, 'black')
  }

  function circle2 (cx, cy, r) {
    var x = 0
    var y = r
    while(x <= y ){
      dot(x + cx, y + cy)
      dot(x + cx, -y + cy)
      dot(-x + cx, y + cy)
      dot(-x + cx, -y + cy)
      dot(y + cx, x + cy)
      dot(y + cx, -x + cy)
      dot(-y + cx, x + cy)
      dot(-y + cx, -x + cy)
      x++
      y1 = y
      y2 = y - 1
      var r1 = (x * x + y1 * y1)
      var r2 = (x * x + y2 * y2)
      var rr = (r * r)

      var d1 = Math.abs(r1 - rr)
      var d2 = Math.abs(r2 - rr)
      if (d1 < d2) {
        y = y1
      } else {
        y = y2
      }
    }
  }

  //画一个实心的圆，半径至少为100像素
  function fillCircle(cx, cy, radius) {
    for (var x = cx - radius; x <= cx + radius; x++) {
      for (var y = cy - radius; y <= cy + radius; y++ ){
        var dx = x - cx
        var dy = y - cy
        if (dx * dx + dy * dy <= radius * radius) {
          dot (x, y)
        }
      }
    }
  }

  //画一个【大小位置都合适】的sin(x)的图像
  for (var x = 0; x < 200; x++) {
    var y = Math.sin(x / 20) * 20
    dot (x, y + 20,'red')
  }

  //画出rgb色彩空间的某一面（尺寸要大于100x100）
  for (var r = 0; r < 256; r++) {
    for (var g = 0; g < 256; g++) {
      var color = 'rgb(' + r + ',' + g + ',255)'
      dot(r + 10, g + 10, color)
    }
  }

  //如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变换后的色彩空间某一面
  //      可以考虑如下几种矩阵：
  //         2 0
  //         0 2
  //         ------
  //         1  0.27
  //         0  1
  //         ------
  //         0.5    0.87
  //         -0.87  0.5

  for (var r = 0; r < 256; r++) {
    for (var g = 0; g < 256; g++) {
      var color = 'rgb(' + r + ',' + g + ',255)'
      var x = 2 * r
      var y = 2 * g
      dot(x + 100, y + 100, color)
      dot(x+1 + 100, y + 100, color)
      dot(x + 100, y+1 + 100, color)
      dot(x+1 + 100, y+1 + 100, color)
    }
  }

  for (var r = 0; r < 256; r++) {
    for (var g = 0; g < 256; g++) {
      var color = 'rgb(' + r + ',' + g + ',255)'
      var x = r
      var y = 0.27 * r + g
      dot(x + 650, y + 650, color)
    }
  }

  for (var r = 0; r < 256; r++) {
    for (var g = 0; g < 256; g++) {
      var color = 'rgb(' + r + ',' + g + ',255)'
      var x = 0.5 * r - 0.87 * g
      var y = 0.87 * r + 0.5 * g
      dot(x + 300, y + 650, color)
    }
  }

  var theta = 0.2

  for (var r = 0; r < 256; r++) {
    for (var g = 0; g < 256; g++) {
      var color = 'rgb(' + r + ',' + g + ',255)'
      var x = r
      var y = g

      x = Math.round(x)
      y = Math.round(y - x * Math.tan(theta / 2))

      x = Math.round(x + Math.sin(theta) * y)
      y = Math.round(y)

      x = Math.round(x)
      y = Math.round(y - x * Math.tan(theta / 2))
      
      dot(x + 650, y + 200, color)
    }
  }

  //画一个二阶贝塞尔曲线（即控制点一共三个）

    var bezierCurve = function(x1,y1,x2,y2,x3,y3) {

      for (var p = 0; p <= 1; p += 0.001){
        var ax = x1 * (1 - p) + x2 * p
        var ay = y1 * (1 - p) + y2 * p
        var bx = x2 * (1 - p) + x3 * p
        var by = y2 * (1 - p) + y3 * p
        var cx = ax * (1 - p) + bx * p
        var cy = ay * (1 - p) + by * p
        dot(cx, cy)
      }
    }

    bezierCurve(200, 200, 300, 500, 200, 600)

    
    var ax = 500
    var ay = 100
    var bx = 630
    var by = 350
    var cx = 950
    var cy = 50

    for (var t = 0; t <= 1; t += 0.002) {
      var x = ax * (1 - t) * (1 - t) + 2 * bx * t * (1 - t) + cx * t * t
      var y = ay * (1 - t) * (1 - t) + 2 * by * t * (1 - t) + cy * t * t
      dot(x, y)
    }

    dot(bx, by)

</script>
</html>